export const meta = {
  title: '2333'
}

# 测试

#### [AnyOf](https://github.com/type-challenges/type-challenges/blob/master/questions/949-medium-anyof/README.md)
只要数组中存在真值就返回为真。注意，如果元素是空数组或者空对象，也认为是假值。
```ts
// 首先构造出可以判断假值的工具类型
// 需要注意空对象类型，利用 keyof {} === never 来进行判断
type FalseType<T> = T extends false | '' | 0 | []
  ? false
  : keyof T extends never
    ? false 
    : true;

type AnyOf<T extends readonly any[]> = T extends [infer F, ...infer Rest]
  ? FalseType<F> extends true
    ? true
    : AnyOf<Rest>
  : false;
```

#### [IsNever](https://github.com/type-challenges/type-challenges/blob/master/questions/1042-medium-isnever/README.md)
判断是不是`never`
```ts
type IsNever<T> = [T] extends [never] ? true : false;
```

#### [Permutation](https://github.com/type-challenges/type-challenges/blob/master/questions/296-medium-permutation/README.md)
实现排列组合类型。
`Permutation<'A' | 'B' | 'C'> === ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']`
```ts
type Permutation<T, V = T> = [T] extends [never]
  ? []
  : T extends T
    ? [T, ...Permutation<Exclude<V, T>>]
    : never;

思路如下：
1. 首先将 A B C 分开，利用联合类型在条件判断中会被解构可以得到：
type T = A | B | C;
T extends T ? [T] : never; // [A] | [B] | [C]
这里就会发现已经得到了三分之一的开头序列，剩下的就是想办法再每一个里面将剩下的两个进行排列
比如在第一个中，如果我们能够将 B 和 C 再次进行类似的操作，就可以得到 [A, B] 和 [A, C]
类似的再继续下去就可以完成第一组的排列了。
```